# Quest 04. OOP의 기본

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.

## Topics
* 객체지향 프로그래밍
  * 프로토타입 기반 객체지향 프로그래밍
  * 자바스크립트 클래스
    * 생성자
    * 멤버 함수
    * 멤버 변수
  * 정보의 은폐
  * 다형성
* 코드의 재사용

## Resources
* [MDN - Classes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
* [MDN - Inheritance and the prototype chain](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* [MDN - Inheritance](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance)
* [Polymorphism](https://medium.com/@viktor.kukurba/object-oriented-programming-in-javascript-3-polymorphism-fb564c9f1ce8)
* [Class Composition](https://alligator.io/js/class-composition/)
* [Inheritance vs Composition](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

## Checklist
`* 객체지향 프로그래밍은 무엇일까요?`

객체지향 프로그래밍은 소프트웨어를 개발하는 방법 중 하나로, 현실 세계의 객체들을 모델링하여 프로그램을 작성하는 패러다임입니다.  
이는 객체라는 단위로 데이터와 해당 데이터를 처리하는 메서드(함수)를 하나의 논리적인 단위로 묶어서 표현합니다.  
객체지향 프로그래밍의 주요 특징은 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism) 등이 있습니다.  
___

  `* # 로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요?`  

데이터의 무결성 보장: 프라이빗 필드를 사용하면 해당 필드에 대한 접근을 제어할 수 있습니다.   
  
이는 잘못된 값이 설정되거나 잘못된 방식으로 변경되는 것을 방지하여 데이터의 무결성을 보장할 수 있습니다.

코드 유연성 증가: 클래스의 내부 구현을 외부로부터 숨기면 클래스를 사용하는 다른 부분에 대한 영향을 최소화할 수 있습니다.   
내부 구현이 변경되더라도 외부에서는 변경 사항을 알 필요가 없으므로 유연성이 증가합니다.  

보안 강화: 프라이빗 필드를 사용하여 중요한 데이터를 보호할 수 있습니다.   
외부에서 직접 접근할 수 없기 때문에 민감한 정보가 노출되는 것을 방지할 수 있습니다.  

코드 유지보수성 향상: 프라이빗 필드를 사용하면 클래스의 내부 구현을 캡슐화할 수 있습니다.  
이는 클래스를 더 쉽게 이해하고 유지보수할 수 있도록 도와줍니다.   

정보 은폐의 주요 장점은 다음과 같습니다:  

데이터의 보호: 객체의 상태를 외부로부터 감추면, 외부에서 직접적으로 데이터에 접근하거나 변경할 수 없습니다.  
이는 데이터의 무결성을 보장하고, 잘못된 변경을 방지하여 안정성을 높입니다.   

코드의 모듈화: 정보 은폐는 객체를 독립적인 모듈로 만들어줍니다.    
외부에서는 객체의 내부 동작 방식에 대해 알 필요 없이 인터페이스를 통해 상호작용할 수 있습니다.   
이는 코드의 모듈화를 촉진하고, 객체 간의 결합도를 낮출 수 있습니다.  

유지보수 용이성: 정보 은폐는 객체의 내부 구현을 외부로부터 분리시킴으로써, 내부 구현의 변경이 외부 코드에 영향을 미치지 않도록 합니다.  
이는 소프트웨어의 유지보수성을 향상시키고, 변경에 대한 부작용을 최소화합니다.  

보안 강화: 정보 은폐는 중요한 데이터나 메서드를 보호할 수 있습니다.   
외부에서 직접 접근이 불가능하므로, 민감한 정보가 노출되는 것을 방지하고 보안을 강화할 수 있습니다.  

추상화: 정보 은폐는 객체의 내부 구현을 추상화시켜 외부에서는 핵심 기능에만 집중할 수 있도록 합니다.   
이는 코드의 가독성을 높이고, 객체의 복잡성을 줄여줍니다.  

___

  `* 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?`  

  다형성(Polymorphism)은 객체지향 프로그래밍에서 사용되는 중요한 개념 중 하나로,   
  같은 이름의 메서드나 함수가 다른 클래스나 객체에 따라 다르게 동작하는 것을 말합니다.   

  메서드 오버라이딩(Method Overriding): 서브 클래스에서 슈퍼 클래스의 메서드를 재정의하는 것을 말합니다.   
  이를 통해 서브 클래스에서는 슈퍼 클래스의 메서드를 동일한 이름으로 사용할 수 있지만,  
  각 클래스에 맞게 다른 동작을 구현할 수 있습니다.

동적 바인딩(Dynamic Binding): 실행 시간에 객체의 타입에 따라 어떤 메서드가 호출될지 결정됩니다.   
이는 다형성의 핵심적인 특징으로, 컴파일 시간에는 어떤 메서드가 호출될지 정해지지 않습니다.  

다형성이 코드 구조의 정리를 도와주는 방법은 다음과 같습니다:  

인터페이스 구현: 다형성을 구현하기 위해 인터페이스를 활용할 수 있습니다.  
인터페이스를 사용하면 클래스 간의 관계를 명확하게 정의하고, 코드를 더 추상화하여 유연성을 높일 수 있습니다.  

코드 재사용: 다형성을 이용하여 같은 인터페이스를 갖는 여러 클래스를 사용할 수 있습니다.   
이는 코드의 재사용성을 높이고, 중복을 줄여서 유지보수성을 향상시킵니다.  

유연한 확장: 새로운 클래스를 추가하거나 기존 클래스를 수정할 필요 없이,   
인터페이스를 통해 다형성을 적용할 수 있습니다. 이는 코드의 확장성을 향상시키고, 시스템의 유연성을 높입니다.  

모듈화: 다형성을 이용하여 코드를 모듈화할 수 있습니다.  
각각의 클래스는 독립적으로 존재하며, 인터페이스를 통해 상호작용하므로 코드의 응집성을 높이고,   
결합도를 낮출 수 있습니다.  

___
  
  `* 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?`  

상속(Inheritance)은 객체지향 프로그래밍에서 클래스들 간에 공통된 특성을 추출하여 하나의 범용 클래스를 정의하고,  
이를 다른 클래스가 확장하여 사용하는 것을 말합니다.  

장점:  

코드의 재사용성: 부모 클래스에서 정의된 속성과 메서드를 자식 클래스에서 재사용할 수 있습니다.   
이는 중복된 코드를 줄여 코드의 양을 줄이고 유지보수성을 향상시킵니다.  

계층 구조 구성: 상속을 통해 클래스들 간에 계층 구조를 형성할 수 있습니다.   
이는 클래스의 관계를 명확하게 정의하고, 코드의 구조를 더욱 직관적으로 만들어 줍니다.  


다형성 구현: 상속은 다형성을 구현하는데 사용됩니다.   
부모 클래스의 타입으로 자식 클래스의 인스턴스를 다룰 수 있어 코드의 유연성을 높이고,   
추상화를 통해 코드의 응집도를 높입니다.  


확장성: 새로운 클래스를 추가할 때, 기존의 클래스를 수정하지 않고 상속을 통해 새로운 기능을 추가할 수 있습니다.  
이는 코드의 확장성을 높이고, 기존 코드에 영향을 주지 않습니다.  


단점:  

클래스 간의 강한 결합: 상속은 클래스 간의 강한 결합을 만들어내므로,   
부모 클래스의 변경이 자식 클래스에 영향을 줄 수 있습니다. 이는 유연성을 감소시킬 수 있습니다.  


복잡성 증가: 상속을 오용하면 클래스 간의 복잡한 계층 구조를 만들어낼 수 있습니다.  
이는 코드의 이해를 어렵게 하고, 디버깅 및 유지보수를 어렵게 할 수 있습니다.  


의존성 증가: 자식 클래스는 부모 클래스에 의존하게 되므로, 부모 클래스의 변경이 자식 클래스에 영향을 줄 수 있습니다.  


이는 시스템의 유연성을 감소시킬 수 있습니다.  
  
___

`* OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?`  

객체지향 프로그래밍(OOP)에서 합성(Composition)은 클래스가 다른 클래스의 인스턴스를 포함하여 그 기능을 이용하는 방식을 말합니다.   
즉, 한 클래스가 다른 클래스의 객체를 사용하여 자신의 기능을 확장하는 것을 의미합니다.  

합성이 상속에 비해 가지는 장점은 다음과 같습니다:  

유연성 증가: 합성은 클래스 간의 관계를 느슨하게 만듭니다.   
따라서 부품 클래스의 변경이 클라이언트 클래스에 영향을 미치지 않으므로 유연성이 증가합니다.  


재사용성 증가: 합성을 사용하면 클래스 간의 의존성을 줄이고 독립적으로 재사용할 수 있는 컴포넌트를 생성할 수 있습니다.   
이는 코드의 재사용성을 높여줍니다.  


계층 구조의 유연성: 합성은 객체 간의 관계를 복합적으로 조합할 수 있으므로 다양한 종류의 객체를 유연하게 조합하여 사용할 수 있습니다.  


명확한 의존성: 합성을 사용하면 클래스 간의 관계가 명확하게 드러납니다.   
부품 객체가 명시적으로 인스턴스화되고 사용되기 때문에 코드의 의도를 더 잘 이해할 수 있습니다.  


다중 상속 문제 회피: 상속은 다중 상속으로 인한 복잡성과 충돌 문제를 발생시킬 수 있지만,   
합성은 이러한 문제를 회피할 수 있습니다.  

___


`* 자바스크립트의 클래스는 어떻게 정의할까요?`  

```class MyClass {
  constructor(prop1, prop2) {
    this.prop1 = prop1;
    this.prop2 = prop2;
  }

  method1() {
    // 메서드 내용
  }

  method2() {
    // 메서드 내용
  }
}
```
___



  `* 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?`  

 프로토타입 기반의 객체지향 프로그래밍은 클래스 기반의 객체지향 프로그래밍과는 다른 접근 방식을 취합니다.  
 
 클래스 기반의 객체지향 프로그래밍에서는 클래스가 객체를 생성하는 틀이 되고,   
 
 이를 통해 객체들이 생성되며 상속 관계가 형성됩니다.   
 
 반면에 프로토타입 기반의 객체지향 프로그래밍에서는 객체가 직접 다른 객체로부터 상속을 받으며,   
 
 클래스가 없는 동적인 객체 생성이 가능합니다.  

프로토타입 기반의 객체지향 프로그래밍은 주로 자바스크립트와 같은 동적인 언어에서 사용되며, 간결하고 유연한 코드 작성을 가능하게 합니다.  

___
  
  `* 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?`  
  
  자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 밀접한 관계가 있습니다.  
  
  ES6(ECMAScript 2015) 이전에는 자바스크립트에서 클래스를 직접적으로 정의할 수 있는 문법이 없었기 때문에 프로토타입을 기반으로 객체지향 프로그래밍을 구현했습니다.  
  
  이는 프로토타입 체인(prototype chain)을 이용하여 상속을 구현하고,  
  
  객체를 생성하는데 사용되는 생성자 함수와 프로토타입 객체를 활용하는 방식을 말합니다.  

 ___
  
## Quest
* 웹 상에서 동작하는 간단한 바탕화면 시스템을 만들 예정입니다.
* 요구사항은 다음과 같습니다:
  * 아이콘은 폴더와 일반 아이콘, 두 가지의 종류가 있습니다.
  * 아이콘들을 드래그를 통해 움직일 수 있어야 합니다.
  * 폴더 아이콘은 더블클릭하면 해당 폴더가 창으로 열리며, 열린 폴더의 창 역시 드래그를 통해 움직일 수 있어야 합니다.
  * 바탕화면의 생성자를 통해 처음에 생겨날 아이콘과 폴더의 개수를 받을 수 있습니다.
  * 여러 개의 바탕화면을 각각 다른 DOM 엘리먼트에서 동시에 운영할 수 있습니다.
  * Drag & Drop API를 사용하지 말고, 실제 마우스 이벤트(mouseover, mousedown, mouseout 등)를 사용하여 구현해 보세요!

## Advanced
* 객체지향의 역사는 어떻게 될까요?
* Smalltalk, Java, Go, Kotlin 등의 언어들로 넘어오면서 객체지향 패러다임 측면에서 어떤 발전이 있었을까요?
